<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="description" content="&lt;h1 id=&#34;广义线性模型&#34;&gt;&lt;a href=&#34;#广义线性模型&#34; class=&#34;headerlink&#34; title=&#34;广义线性模型&#34;&gt;&lt;/a&gt;广义线性模型&lt;/h1&gt;&lt;h2 id=&#34;普通最小二乘法&#34;&gt;&lt;a href=&#34;#普通最小二乘法&#34; class=&#34;headerlink&#34; title=&#34;普通最小二乘法&#34;&gt;&lt;/a&gt;普通最小二乘法&lt;/h2&gt;&lt;figure class=&#34;highlight pytho">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=yes">
  <title>sklearn广义线性模型 | Zima Blue&#39;s blog</title>

  <link rel="stylesheet" id="chosen-theme" href="https://rawgit.com/fiatjaf/classless/master/themes/plain/theme.css">
  <script>
let link = document.getElementById('chosen-theme')
let widget = document.createElement('div')
widget.style.position = 'absolute'
widget.style.right = '5px'
widget.style.top = '2px'
widget.style.background = 'beige'
widget.style.color = '#444'
widget.style.zIndex = 99
widget.style.padding = '4px 8px'
widget.innerHTML = `
<label>
  <p>No theme was set on <code>theme_config</code>.<br>
     Choose a theme from the list to experiment with it:</p>
  <select></select>
</label>
`
fetch('https://api.github.com/repos/fiatjaf/classless/contents/themes')
  .then(r => r.json())
  .then(files => {
    document.body.appendChild(widget)
    let select = document.querySelector('select')
    files
      .filter(f => f.type === 'dir')
      .forEach(f => {
        let option = document.createElement('option')
        option.value = f.name
        option.innerHTML = f.name
        select.appendChild(option)
      })
    let options = Array.from(select.querySelectorAll('option'))
    let chosen = options[parseInt(Math.random() * options.length)]
    chosen.selected = true
    link.href = link.href.replace(/themes\/[^\/]+/, `themes/${chosen.value}`)
    select.addEventListener('change', e => {
      let chosen = e.target.value
      link.href = link.href.replace(/themes\/[^\/]+/, `themes/${chosen}`)
    })
  })
  .catch(console.log)
  </script>

<meta name="generator" content="Hexo 5.0.0"></head>

<body>
  <header role="banner">
    <a href="/">
      <img src="https://picsum.photos/640/480">
    </a>
    <h1>
      <a href="/">Zima Blue&#39;s blog</a>
    </h1>
    <aside>
      <p></p>
    </aside>
  </header>
  <nav>
    <ul>
      
      <li>
        <a href="/">Home</a>
      </li>
      
      <li>
        <a href="/archives/">Archives</a>
      </li>
      
    </ul>
  </nav>
  <main>
    <article>
  <header>
  
  <h1><a href="http://yoursite.com/2020/07/29/%E5%B9%BF%E4%B9%89%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/">sklearn广义线性模型</a></h1>
  <aside>
    
    <time datetime="202020-07-29">
      July 29th 2020
    </time>
    
    <ul>
    
    </ul>
  </aside>
</header>

  <div><h1 id="广义线性模型"><a href="#广义线性模型" class="headerlink" title="广义线性模型"></a>广义线性模型</h1><h2 id="普通最小二乘法"><a href="#普通最小二乘法" class="headerlink" title="普通最小二乘法"></a>普通最小二乘法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"></span><br><span class="line">reg = linear_model.LinearRegression()</span><br><span class="line">reg.fit([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># y=x+1</span></span><br><span class="line">print(reg.coef_)  <span class="comment"># 参数值</span></span><br><span class="line">print(reg.intercept_)  <span class="comment"># 截距</span></span><br><span class="line">print(reg.predict([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>]]))  <span class="comment"># 想要预测的数据，放到一个列表中</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="number">0.5</span> <span class="number">0.5</span>]</span><br><span class="line"><span class="number">5.551115123125783e-17</span></span><br><span class="line">[<span class="number">1.5</span> <span class="number">2.5</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinearRegression(copy_X=<span class="literal">True</span>, fit_intercept=<span class="literal">True</span>, n_jobs=<span class="number">1</span>, normalize=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>fit_intercept：bool, default=True</p>
<p>是否计算截距</p>
</li>
<li><p><strong>normalize</strong>：bool, default=False</p>
<p>是否将数据标准化</p>
</li>
<li><p><strong>copy_X</strong>：bool, default=True</p>
<p>如果为True，将复制X；否则为X。否则，它可能会被覆盖。</p>
</li>
<li><p><strong>n_jobs</strong>：int, default=None</p>
<p>使用进程的数量，与电脑的CPU有关，-1表示使用所有处理器</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fit(self, X, y, sample_weight=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>X是自变量，y是每个自变量所对应的因变量，sample_weight是每个自变量的权重</p>
<h2 id="岭回归"><a href="#岭回归" class="headerlink" title="岭回归"></a>岭回归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"></span><br><span class="line">reg = linear_model.Ridge(alpha=<span class="number">.5</span>)  <span class="comment"># alpha参数大于0</span></span><br><span class="line">reg.fit([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]], [<span class="number">0</span>, <span class="number">.1</span>, <span class="number">1</span>])</span><br><span class="line">print(reg.coef_, reg.intercept_, reg.predict([[<span class="number">3</span>, <span class="number">3</span>]]))</span><br></pre></td></tr></table></figure>

<p>除了创建时不同，与其他线性模型一样， <a target="_blank" rel="noopener" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html#sklearn.linear_model.Ridge"><code>Ridge</code></a> 用 <code>fit</code> 方法完成拟合，并将模型系数 ω 存储在其 <code>coef_</code> 成员中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ridge(alpha=<span class="number">1.0</span>, fit_intercept=<span class="literal">True</span>, normalize=<span class="literal">False</span>, copy_X=<span class="literal">True</span>, max_iter=<span class="literal">None</span>, tol=<span class="number">0.001</span>, solver=<span class="string">&#x27;auto&#x27;</span>, random_state=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>alpha</strong>：float, ndarray of shape (n_targets), default=1.0</p>
<p>正则化参数，传入的是正浮点数，如果有多个惩罚项则传入数组</p>
</li>
<li><p><strong>fit_intercept</strong>：boolean, optional, default True</p>
<p>是否计算截距。如果为False，对数据进行去中心化处理。</p>
</li>
<li><p><strong>normalize</strong>：boolean, optional, default False</p>
<p>对数据X进行标准化</p>
</li>
<li><p><strong>max_iter</strong>：int, default=None</p>
<p>共轭梯度求解器的最大迭代次数。</p>
</li>
<li><p><strong>tol：</strong>float, optional</p>
</li>
</ul>
<p>　　优化容忍度：如果更新大于tol，继续优化，直到小于tol。</p>
<ul>
<li><p><strong>solver</strong>：{‘auto’, ‘svd’, ‘cholesky’, ‘lsqr’, ‘sparse_cg’, ‘sag’, ‘saga’}, default=’auto’</p>
<p>参数计算方式</p>
<p>auto：根据数据类型自动选择求解器。</p>
<p>svd：使用X的奇异值分解来计算Ridge系数，对于奇异矩阵，比cholesky更稳定。</p>
<p>cholesky：使用标准的scipy.linalg.solve函数来获取封闭形式的解决方案。</p>
<p>sparse_cg：使用scipy.sparse.linalg.cg中的共轭梯度求解器。作为一种迭代算法，对于大规模数据（可以设置tol和max_iter），此求解器比cholesky更合适。</p>
<p> lsqr：使用专用的正则化最小二乘例程scipy.sparse.linalg.lsqr。它是最快的，并且使用迭代过程。</p>
<p> sag和saga：sag使用随机平均梯度下降，saga使用经过改进的无偏版本SAGA。两种方法都使用迭代过程，并且当n_samples和n_features都较大时，通常比其他求解器更快。请注意，只有在比例大致相同的要素上才能确保“ sag”和“ saga”快速收敛。您可以使用sklearn.preprocessing中的缩放器对数据进行预处理。</p>
</li>
<li><p><strong>random_state：</strong>int, RandomState instance or None, optional, default None</p>
<p>伪随机数发生器种子，随机选择特征来更新模型。如果为int，random_state即为随机数发生器使用的种子；如果为RandomState实例，random_state即为随机数发生器；如果为None，随机数发生器为np.random使用的随机数发生器实例。该参数仅当selection=‘random’时使用。</p>
</li>
</ul>
<h5 id="岭回归所解决的问题："><a href="#岭回归所解决的问题：" class="headerlink" title="岭回归所解决的问题："></a><strong>岭回归所解决的问题：</strong></h5><p>普通最小二乘法会在实际应用中遇到以下问题：</p>
<p>（1）数据样本数比特征数少的情况，矩阵的逆不能直接计算，当求n元一次方程组时，需要有n个方程才可以求出唯一解，也就是说最少需要n个样本。</p>
<p>（2）即使样本数多于特征数，若特征高度相关，X^T^X的逆依然无法计算。</p>
<p>   (3)  过拟合</p>
<h5 id="设置正则化参数：广义交叉验证"><a href="#设置正则化参数：广义交叉验证" class="headerlink" title="设置正则化参数：广义交叉验证"></a>设置正则化参数：广义交叉验证</h5><p><a target="_blank" rel="noopener" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.RidgeCV.html#sklearn.linear_model.RidgeCV"><code>RidgeCV</code></a> 通过内置的关于的 alpha 参数的交叉验证来实现岭回归。 </p>
<p>默认为 Generalized Cross-Validation(广义交叉验证 GCV)，这是一种有效的留一验证方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line">reg = linear_model.RidgeCV(alphas=[<span class="number">0.1</span>, <span class="number">1.0</span>, <span class="number">10.0</span>])</span><br><span class="line">reg.fit([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]], [<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">1</span>])</span><br><span class="line">print(reg.alpha_)  <span class="comment"># 得出的正则化参数</span></span><br></pre></td></tr></table></figure>

<p>指定cv属性的值将触发(通过GridSearchCV的)交叉验证。例如，cv=10将触发10折的交叉验证，而不是广义交叉验证(GCV)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RidgeCV(alphas=(<span class="number">0.1</span>, <span class="number">1.0</span>, <span class="number">10.0</span>), fit_intercept=<span class="literal">True</span>, normalize=<span class="literal">False</span>, scoring=<span class="literal">None</span>, cv=<span class="literal">None</span>, gcv_mode=<span class="literal">None</span>, store_cv_values=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>gcv_mode</strong>：{‘auto’, ‘svd’, eigen’}, default=’auto’</p>
<p>指示执行通用交叉验证时使用哪种策略的标志</p>
</li>
</ul>
<h2 id="Lasso回归"><a href="#Lasso回归" class="headerlink" title="Lasso回归"></a>Lasso回归</h2><p><a target="_blank" rel="noopener" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Lasso.html#sklearn.linear_model.Lasso"><code>Lasso</code></a> 类的实现使用了 coordinate descent （坐标下降算法）来拟合系数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"></span><br><span class="line">reg = linear_model.Lasso(alpha=<span class="number">0.1</span>)</span><br><span class="line">reg.fit([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">print(reg.predict([[<span class="number">1</span>, <span class="number">1</span>]]), reg.coef_, reg.intercept_)</span><br></pre></td></tr></table></figure>

<p>对于较简单的任务，同样有用的是函数 <a target="_blank" rel="noopener" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.lasso_path.html#sklearn.linear_model.lasso_path"><code>lasso_path</code></a> 。它能够通过搜索所有可能的路径上的值来计算系数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lasso(alpha=<span class="number">1.0</span>, *, fit_intercept=<span class="literal">True</span>, normalize=<span class="literal">False</span>, precompute=<span class="literal">False</span>, copy_X=<span class="literal">True</span>, max_iter=<span class="number">1000</span>, tol=<span class="number">0.0001</span>, warm_start=<span class="literal">False</span>, positive=<span class="literal">False</span>, random_state=<span class="literal">None</span>, selection=<span class="string">&#x27;cyclic&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>alpha：</strong>float, optional</li>
</ul>
<p>　　正则项参数。常数。默认值1.0。alpha=0时转化为最小二乘估计，由线性回归模型求解。使用Lasso模型时，通常令alpha≠0。</p>
<ul>
<li><strong>fit_intercept：</strong>boolean, optional, default True</li>
</ul>
<p>　　是否计算截距。如果为False，对数据进行去中心化处理。</p>
<ul>
<li><strong>normalize：</strong>boolean, optional, default False</li>
</ul>
<p>　　对数据X进行标准化</p>
<ul>
<li><strong>precompute：</strong>True | False | array-like, default=False</li>
</ul>
<p>　　是否使用事先计算好的Gram矩阵来加速模型计算。如果precompute=’auto’，让程序自动决定。Gram矩阵可以作为参数被传递。对于稀疏数据，通常令precompute=True，保留稀疏性。</p>
<ul>
<li><strong>copy_X：</strong>boolean, optional, default True</li>
</ul>
<p>　　如果copy_X=True，复制X；如果copy_X=False，覆盖上次运行的X。</p>
<ul>
<li><strong>max_iter：</strong>int, optional</li>
</ul>
<p>　　最大迭代次数。</p>
<ul>
<li><strong>tol：</strong>float, optional</li>
</ul>
<p>　　优化容忍度：如果更新大于tol，继续优化，直到小于tol。</p>
<ul>
<li><strong>warm_start：</strong>bool, optional</li>
</ul>
<p>　　如果warm_start=True，使用上次的解作为初始化；如果warm_start=False，清除之前的解。</p>
<ul>
<li><strong>positive：</strong>bool, optional</li>
</ul>
<p>　　如果positive=True，强制将系数设为正数。</p>
<ul>
<li><p><strong>random_state：</strong>int, RandomState instance or None, optional, default None</p>
<p>伪随机数发生器种子，随机选择特征来更新模型。</p>
</li>
<li><p><strong>selection：</strong>str, default ‘cyclic’</p>
<p>如果为‘random’，每次迭代都会更新随机系数，而不是按顺序遍历每个特征。该参数值可以使得算法更快收敛，尤其当tol&gt;1e-4时。</p>
</li>
</ul>
</div>
</article>

  </main>
  <aside>
    <p>This is an `aside`, a useful place to put information of any kind: metadata about the site author (with or without pictures), brief information about the purposes of the site, a static collection of external links or anything else.</p>
<p>For some Classless themes pictures and data about the author may suit better in the `cover` and `description` site attributes (see `config.toml`), but most of the times that kind of information will fit here better.</p>

  </aside>
  <footer role="contentinfo">
    <p>A default site footer. If you don't know what to place here maybe you should just write your name plus the current year?</p>
<p>If you want to have a sitemap, a contact form or other complex stuff, most Classless themes will also handle it nicely. Or you can take a look at the <code>aside.html</code> partial.</p>

  </footer>
</body>
